= Install and Start Using the Scala SDK with Couchbase Server
:navtitle: Start Using the SDK
:page-topic-type: howto

[abstract]
The Couchbase Scala SDK enables you to interact with a Couchbase Server cluster from the Scala language.

WARNING: These pages cover the first _Developer Preview_ of the Couchbase Scala SDK 1.0 (DP1).
As such they are likely to change without notice.
The DP1 code _should not_ be used in production.

== Installing the SDK

The Couchbase Scala SDK will ultimately be distributed on the Maven repository, but in its Developer Preview state the jar file should be placed in a `lib` directory.

Create a `lib` in the root of the project, in the same directory as the `build.gradle` file.

Add the following to `build.gradle` to tell it to look for jars in the `lib` directory, and to use the Couchbase Scala SDK jar: 

[source,groovy]
----
repositories {
    flatDir {
        dirs 'libs'
    }
}

dependencies {
    compile group: 'com.couchbase.client', name: 'scala-client', version: '1.0.0-DP1'  **FIXVERSION**
}
----

== Hello Couchbase

Now you have the Scala client installed, open a fresh project in your favourite IDE and try out the following to connect to a Couchbase cluster.

You'll need to provide the IP address of one of the nodes of the Couchbase cluster. 
If you're developing client code on the same VM or machine as the Couchbase Server, this can be _localhost_.  
Couchbase uses xref:6.5@server:learn/security:roles.adoc[Role Based Access Control (RBAC)] to control access to resources, so specify the username and password of a user you've setup during installation of the Couchbase Data Platform.


[source,scala]
----
include::example$Cluster.scala[tag=cluster]
----

You can now open bucket, scope, and collection resources:

[source,scala]
----
include::example$Cluster.scala[tag=resources]
----

The 3.0 SDK is ready for the introduction of xref:#[Collections] in a forthcoming release of the Couchbase Data Platform.
The latest release, Mad Hatter, brings a limited _Developer Preview_ of Collections, allowing Documents to be grouped by purpose or theme, according to specified _Scope_.

Now we can do some simple Key Value (KV) operations. 
First, let's create some JSON.  
The Scala SDK directly supports several popular JSON libraries, including https://github.com/lihaoyi/upickle[uPickle/uJson], https://circe.github.io/circe/[Circe], https://github.com/playframework/play-json[Play Json], https://github.com/typelevel/jawn[Jawn], and https://github.com/json4s/json4s[Json4s] (if you'd like to see your favourite supported, please let us know). 
In addition you can supply JSON encoded into a `String` or `Array[Byte]`, opening the door to any JSON library; https://jsoniter.com/[Jsoniter] and https://github.com/FasterXML/jackson[Jackson] have been tested, but any should work.

To make things easy and to help get you started, the Scala SDK also bundles a home-grown small JSON library, which you are free to use instead of or alongside any of the other supported JSON libraries. 
The philosophy behind this library is to provide a very easy-to-use API and the fastest JSON implementation possible. 
Everything that benchmarking found made it slower was removed, so you'll find that it's mutable, and there are no lenses or cursors or other functional goodies: for those, you can look to one of the other supported libraries, such as the excellent Circe.

We can use the Scala SDK's built in JSON library, or many of the alternative JSON libraries above, to directly encode and decode Scala case classes with Couchbase. 
But let's start simple and create some (very simple) JSON like this:

[source,scala]
----
include::example$Cluster.scala[tag=json]
----

And now let's upsert it into Couchbase (upsert is an operation that will insert the document if it does not exist, or replace it if it does).  
We need to provide a unique ID for the JSON, and we'll use a UUID here:

[source,scala]
----
include::example$Cluster.scala[tag=upsert]
----

A note on error handling: the Scala SDK will not throw exceptions. 
Instead, methods that can error will return a Scala `Try` object, which can either be a `Success` containing the result, or a `Failure` containing a _Throwable_ exception. 
The easiest way to handle a single operation is with pattern matching, as shown above.

Now let's get the data back (this example will look a little messy, but we'll see how to clean it up shortly):

[source,scala]
----
include::example$Cluster.scala[tag=get]
----

Here we're fetching the value for the key `docId`, converting that value to a `JsonObject`, and then accessing the value of the *status* key as a String.

All three of these operations could fail, so there's quite a lot of error handling code here to do something quite simple.
One way to improve on this is by using flatmap, like this:

[source,scala]
----
include::example$Cluster.scala[tag=get-map]
----

Alternatively, you can use a for-comprehension, like so:

[source,scala]
----
include::example$Cluster.scala[tag=get-for]
----

// TODO FIXLINK
KV Operations are described in detail on the xref:scala-sdk:howtos:kv-operations.adoc[KV Operations page].
Now that you know the basics, you may wish to go straight to that page.

== Additional Resources

// TODO FIXLINK
The API reference is generated for each release and can be found xref:http://docs.couchbase.com/sdk-api/couchbase-scala-client-3.0.0dp1/[here].

Couchbase welcomes community contributions to the Scala SDK.
The source code is available on xref:https://github.com/couchbase/couchbase-jvm-clients[GitHub].

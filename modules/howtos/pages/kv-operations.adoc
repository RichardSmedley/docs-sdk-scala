= Key Value Operations
:navtitle: KV Operations
:page-topic-type: howto
:page-aliases: document-operations.adoc

WARNING: These pages cover the first _Alpha_ of the Couchbase Scala SDK -- 1.0 _alpha_.
As such they are likely to change without notice.
The _alpha_ code _should not_ be used in production.

At its heart Couchbase Server is a high-performance key-value store, and the key-value interface outlined below is the fastest and best method to perform operations involving single documents.

A _document_ refers to an entry in the database (other databases may refer to the same concept as a _row_).
A document has an ID (_primary key_ in other databases), which is unique to the document and by which it can be located.
The document also has a value which contains the actual application data.
See xref:concept-docs:documents.adoc[the concept guide to _Documents_] for a deeper dive into documents in the Couchbase Data Platform.

Before proceeding, make sure you're familiar with the basics of authorization and connecting to a Cluster from the xref::start-using-sdk.adoc[Start Using the SDK] section.

The code samples below will use these imports:

[source,scala]
----
include::example$KvOperations.scala[tag=imports]
----

[TIP]
N1QL can also be used to perform many single-document operations but we very strongly recommend using the key-value API for this instead, as it can be much more efficient.  The request can go directly to the correct node, there's no query parsing overhead, and it's over the highly optimized memcached binary protocol.

== JSON
The Couchbase Server is a key-value store that's agnostic to what's stored, but it's very common to store JSON so most of the examples below will focus on that use-case.

The Scala SDK provides you with several options for working with JSON.

It directly supports several popular JSON libraries: https://github.com/lihaoyi/upickle[uPickle/uJson], https://circe.github.io/circe/[Circe], https://github.com/playframework/play-json[Play Json], https://github.com/typelevel/jawn[Jawn], and https://github.com/json4s/json4s[Json4s].

In addition you can supply and receive JSON as a `String` or `Array[Byte]`, opening the door to any JSON library; https://jsoniter.com/[Jsoniter] and https://github.com/FasterXML/jackson[Jackson] have been tested, but any should work.

You can also directly encode and decode Scala case classes to and from the SDK.

To make things easy and to help get you started, the Scala SDK also bundles a home-grown small JSON library, which you are free to use instead of or alongside any of the other supported JSON libraries.
The philosophy behind this library is to provide a very easy-to-use API and the fastest JSON implementation possible.

=== Using JsonObject and JsonArray
Using the built-in JSON library here's how to create some simple JSON:

[source,scala]
----
include::example$KvOperations.scala[tag=json1]
----

`JsonObject` and `JsonArray` are both mutable, so they can also be created this way:

[source,scala]
----
include::example$KvOperations.scala[tag=json-mutable]
----

It's easy to retrieve data:

[source,scala]
----
include::example$KvOperations.scala[tag=json2]
----

Or, using a feature of Scala called `Dynamic`, you can use an alternative syntax like this:

[source,scala]
----
include::example$KvOperations.scala[tag=json3]
----

The majority of the Scala SDK will not throw exceptions.  Methods on `JsonObject` are, well, an exception to this rule.

If you'd rather not deal with exceptions, `JsonObject` comes with a counterpart `JsonObjectSafe` that provides an alternative interface in which all methods return Scala `Try` rather than throwing:

[source,scala]
----
include::example$KvOperations.scala[tag=json4]
----

(Don't worry if `Try` is unfamiliar, you'll see plenty of examples of how to use it and combine it with other `Try` in the examples below.)

Note that `JsonObjectSafe`, though presenting a more functional interface, is still mutable.  A `JsonArraySafe` counterpart exists.

[NOTE]
Using JsonObject and JsonArray is 100% optional.  If you would rather use a purely functional JSON library, with immutable
data, lenses, cursors and other functional goodies, then the Scala SDK includes full support
for the excellent https://circe.github.io/circe/[Circe], among other great JSON libraries.

== Upsert
Here is a simple upsert operation, which will insert the document if it does not exist, or replace it if it does.

We'll use the built-in JSON library for simplicity, but remember there are many other ways to put JSON into Couchbase:

[source,scala]
----
include::example$KvOperations.scala[tag=upsert]
----

[NOTE]
=====
All the examples here use the Scala SDK's simplest API, which blocks until the operation is performed.  There's also an asynchronous API that is based around Scala `Future`, and a
reactive API built around https://projectreactor.io/[Project Reactor].  They can be accessed like this:

[source,scala]
----
include::example$KvOperations.scala[tag=apis]
----
=====

== Handling Single Errors
A note on error handling: the Scala SDK will not throw exceptions.
 
Instead, methods that can error will return a Scala `Try` object, which can either be a `Success` containing the result, or a `Failure` containing a _Throwable_ exception.
 
Pattern matching can be used to handle a `Try`, as above.

Don't worry about cluttering up your code with explicit error handling for every operation: Scala provides useful methods to chain multiple `Try` together, and we'll go into these later.

[NOTE]
We will use `println` to simply print any errors in these samples, but the application will of course want to perform better error handling.

== Insert
Insert works very similarly to upsert, but will fail if the document already exists:

[source,scala]
----
include::example$KvOperations.scala[tag=insert]
----

Note that a `Try` lets us check for a particular sort of error.  The case clauses are tried in order from the top: if it is not a `Success`, and not a `Failure` containing a `DocumentAlreadyExistsException`, it will drop to the default `Failure(err)` case. 

== Retrieving Documents

We've tried upserting and inserting documents into Couchbase Server, let's get them back:

[source,scala]
----
include::example$KvOperations.scala[tag=get-simple]
----

Of course if we're getting a document we probably want to do something with the content:

[source,scala]
----
include::example$KvOperations.scala[tag=get]
----

Woah, this looks messy!  Don't worry, this is the ugliest possible way of handling multiple `Try` results and we'll see ways of tidying this up very soon.

For now, let's break down what's going on here.

First, we create some JSON and insert it.

Then, we get the document.

If it's successful, we convert the document's content into a `JsonObjectSafe`.

We can use `contentAs` to return the document's
content in all sorts of ways: as a String, as an Array[Byte], as a `org.json4s.JValue` from the https://github.com/json4s/json4s[json4s library]... it's very flexible.  Here,
we've asked for it to be returned as a `JsonObjectSafe` - a 'safe' interface to the `JsonObject` that doesn't throw exceptions.

Finally, if the conversion to a `JsonObjectSafe` was successful, we try to get the "status" field (which returns a `Try` with `JsonObjectSafe`), and print it if we were successful.

== Handling Multiple Errors
Nesting multiple `Try` in that way quickly gets very hard to parse.  Luckily, Scala provides functional tools to easily combine `Try` and handle them in one place.

First there's `flatMap`, which can be used to rewrite the previous example like this:

[source,scala]
----
include::example$KvOperations.scala[tag=get-map]
----

Here, if the `get` is successful then the `contentAs` is tried, and if that is successful then the `str` call is tried.  The end result is a single `Try[String]` that will be `Success` if all three operations succeeded, or otherwise `Failure`.

Some may prefer a for-comprehension, which is simply syntactic sugar around the `flatMap` example:

[source,scala]
----
include::example$KvOperations.scala[tag=get-for]
----

== Replace
A very common operation is to `get` a document, modify its contents, and `replace` it.  Let's use a for-comprehension:

[source,scala]
----
include::example$KvOperations.scala[tag=replace]
----

There's a couple of things to cover with the `replace` line.

First, most of the methods in the Scala SDK take optional parameters that have sensible defaults.  One of them, `cas`, is provided here.  We'll see more throughout this document.

So, what is CAS?

CAS, or Compare and Swap, is a form of optimistic locking.  Every document in Couchbase has a CAS value, and it's changed on every mutation.  When you `get` a document you also get the document's CAS, and then when it's time to write the document, you send the same CAS back.  If another agent has modified that document, the Couchbase Server can detect you've provided a now-outdated CAS, and return an error.  This provides cheap, safe concurrency.  See xref:concurrent-document-mutations.adoc[this detailed description of CAS] for further details.

In general, you'll want to provide a CAS value whenever you `replace` a document, to prevent overwriting another agent's mutations.

== Retrying on CAS Failures
But if we get a CAS mismatch, we usually just want to retry the operation.  Let's see a more advanced `replace` example that shows one way to handle this:

[source,scala]
----
include::example$KvOperations.scala[tag=replace-retry]
----

== Removing
Removing a document is straightforward:

[source,scala]
----
include::example$KvOperations.scala[tag=remove]
----

== Sub-Document Operations
All of the operations seen so far involve fetching the complete document.

As an optimization the application may consider using the xref:subdocument-operations.adoc[Sub-Document API] to access or mutate specific parts of a document.

== Case Classes
So far we've used JSON directly with `JsonObject` and `JsonObjectSafe`, but it can be very useful to deal with Scala case classes instead.

Let's start by creating a couple of simple case classes:

[source,scala]
----
include::example$KvOperations.scala[tag=cc-create]
----

If we try and insert this case class directly, we'll get an error, e.g. this won't work:

[source,scala]
----
include::example$KvOperations.scala[tag=cc-fails]
----

This is because the Scala SDK does not currently know how to convert a `User` into JSON it can send to the server.

More technically, methods like `insert` that take content of type `T` also take an implicit `Encodable[T]`, which defines how to turn `T` into JSON.  If the Scala compiler cannot find a suitable `Encodable[T]`, then it will report an error.

So, let's provide an `Encodable[User]`.  It's not complicated to create one manually, but the Scala SDK includes a convenient shortcut:

[source,scala]
----
include::example$KvOperations.scala[tag=cc-codec]
----

(As this is a companion object for User, it needs to go in the same file as the `User` case class you added earlier.)

This short line of boilerplate uses Scala macros to, at compile time, provide an `Encodable[User]`.  Note that we don't need one for `Address` too - only the top-level case classes you're dealing with need a `Codec`.

Now we can pass a `User` directly to `insert`, and it will work fine.  The Scala compiler will look for an `Encodable[User]` in a number of places, and find it in the `User` companion object.

Since the encoding logic is generated at compile time it can also be extremely fast - no reflection is used.

The generated JSON will be as you expect, with "name" and "age" fields, and an "addresses" array.

The same `Codec` also generates a `Decodable[User]` which can be used to pull data out as our case class, using `contentAs`:

[source,scala]
----
include::example$KvOperations.scala[tag=cc-get]
----

[NOTE]
====
There are other ways to handle case classes.  Most of the previously mentioned supported JSON libraries have a method to encode and decode case classes, and these can be used with the Scala SDK.

For example, you could use `asJson` from the library https://circe.github.io/circe/[Circe] to convert the User into Circe's JSON representation.  The Scala SDK has an `Encodable[io.circe.Json]` built-in for this, so it will work.  Similar
`Encodable` exist for the other supported JSON libraries.

Or you could use https://github.com/plokhotnyuk/jsoniter-scala[Jsoniter] or a similar library to convert the User into an `Array[Byte]` or `String`, and provide that.  An `Encodable` also exists for these.
====

== Durability
Writes in Couchbase are written to a single node, and from there the Couchbase Server will take care of sending that mutation to any configured replicas.

The optional `durability` parameter, which all mutating operations accept, allows the application to wait until this replication is successful before proceeding.

It can be used like this:

[source,scala]
----
include::example$KvOperations.scala[tag=durability]
----

The default is `Durability.Disabled`, in which the SDK will return as soon as Couchbase Server has the mutation available in-memory on the master node.  This is the default for a reason: it's the fastest mode, and the majority of the time is all the application needs.  Couchbase Server is designed, after all, to preserve your data in the advent of node and network failures.

However, we recognize that there are times when the application needs that extra certainty that especially vital mutations have been successfully replicated, and the other durability options provide the means to achieve this.

The options differ depend on what Couchbase Server version is in use.  If 6.5 or above is being used, you can take advantage of the 'synchronous replication' feature, in which Couchbase Server will only return success to the SDK after the requested replication level has been achieved.  The three replication levels are:

`Majority` - The server will ensure that the change is available in memory on the majority of configured replicas.

`MajorityAndPersistOnMaster` - Majority level, plus persisted to disk on the master node.

`PersistToMajority` - Majority level, plus persisted to disk on the majority of configured replicas.

The options are in increasing levels of safety.  Note that nothing comes for free - for a given node, waiting for writes to storage is considerably slower than waiting for it to be available in-memory.

In a version of Couchbase Server lower than 6.5 is being used then the application can fall-back to 'client verified' durability.  Here the SDK will do a simple poll of the replicas and only return once the requested durability level is achieved.  This can be achieved like this:

[source,scala]
----
include::example$KvOperations.scala[tag=durability-observed]
----

To stress, durability is a useful feature but should not be the default for most applications, as there is a performance consideration, and the default level of safety provided by Couchbase will be resaonable for the majority of situations.

== Expiration/TTL
Couchbase Server includes an option to have particular documents automatically expire after a set time.  This can be useful for some use-cases, such as user sessions, caches, or other temporary documents.

You can set an expiration value when creating a document:

[source,scala]
----
include::example$KvOperations.scala[tag=expiry-insert]
----

When getting a document, the expiry is not provided automatically by Couchbase Server but it can be requested:

[source,scala]
----
include::example$KvOperations.scala[tag=expiry-get]
----

Note that when updating the document, special care must be taken to avoid resetting the expiry to zero.  Here's how:

[source,scala]
----
include::example$KvOperations.scala[tag=expiry-replace]
----

Some applications may find `getAndTouch` useful, which fetches a document while updating its expiry field.  It can be used like this:

[source,scala]
----
include::example$KvOperations.scala[tag=expiry-touch]
----

== Counter Operations
To support counter use-cases, a Couchbase document can be treated as an integer counter and adjusted or created atomically like this:

[source,scala]
----
include::example$KvOperations.scala[tag=counter-increment]
----

Note that a counter cannot be below 0.

== Additional Resources

Working on just a specific path within a JSON document will reduce network bandwidth requirements - see the xref:subdocument-operations.adoc[Sub-Document] pages.

For working with metadata on a document, reference our xref:sdk-xattr-example.adoc[Extended Attributes] pages.

// Another way of increasing network performance is to _pipeline_ operations with xref:batching-operations.adoc[Batching Operations].

// As well as various xref:concept-docs:data-model.adoc[Formats] of JSON, Couchbase can work directly with xref:non-json.adoc[arbitrary bytes, or binary format].

Our xref:n1ql-queries-with-sdk.adoc[Query Engine] enables retrieval of information using the SQL-like syntax of N1QL.

